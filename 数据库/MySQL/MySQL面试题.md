1. **InnoDB 存储引擎**：InnoDB 存储引擎与 MyISAM 相比，在事务支持、锁机制和崩溃恢复方面有哪些关键差异？

   * **事务支持**：InnoDB 支持ACID事务，MyISAM 完全不支持事务；
   * **锁机制**：InnoDB支持行级锁和表级锁，而MyISAM只支持表级锁（读锁/写锁），并发性能远低于InnoDB；
   * **崩溃恢复**：InnoDB通过redo log和WAL（Write-Ahead Logging）机制实现crash-safe，崩溃后可恢复；MyISAM无崩溃恢复能力，崩溃可能导致数据损坏；
   * **其他关键差异**：InnoDB支持外键约束，MyISAM不支持；InnoDB主键索引为聚簇索引（叶子节点存储行数据），MyISAM所有索引均为非聚簇索引（叶子节点存储行地址）。

2. **B + 树索引**：B + 树索引的叶子节点和非叶子节点分别存储什么内容？为什么说 B + 树索引适合范围查询？

   * **节点内容**：
     * 非叶子节点：仅存储索引键和指向子节点的指针（作为“目录”，不存放实际数据）；
     * 叶子节点：InnoDB中，聚簇索引的叶子节点存储完整行数据；辅助索引的叶子节点存储主键值（通过主键回表查询完整数据）。

   * **范围查询优势**：B+树所有叶子节点按索引键有序排列，且通过双向链表连接，范围查询时无需回溯上层节点，只需遍历链表即可高效获取连续数据，而B树因非叶子节点存数据，范围查询需频繁回溯，效率更低。

3. **事务隔离级别**：请解释 MySQL 中读未提交、读已提交、可重复读、串行化这四种事务隔离级别的具体含义。

   * **读未提交**：事务未提交的变更可被其他事务看到，可能导致**脏读**（读取到未提交的无效数据）；

   * **读已提交**：事务提交后，变更才对其他事务可见，解决脏读，但可能导致**不可重复读**（同一事务内多次查询结果不一致）；

   * **可重复读**：InnoDB默认隔离级别，一个事务启动后，看到的数据始终跟这个事务启动时看到的数据是一致的，解决不可重复读；通过间隙锁可避免**幻读**（查询范围内突然新增数据）；

   * **串行化**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成，才能继续执行，完全避免并发问题，但性能极低，适用于数据一致性要求极高的场景。

4. **锁机制基础**：InnoDB 中的行锁和表锁在什么场景下会触发？请简单说明意向锁的作用。

   * **行锁触发**：使用当前读语句（`select ... for update`加排他锁X，`select ... lock in share mode`加共享锁S）时，若查询命中索引，会对匹配的行加行锁；若未命中索引，会升级为表锁。
   * **表锁触发**：
     * 命令显示加锁：`lock tables t read/write`；
     * DDL操作（如`alter table`）默认加表级排他锁；
     * 无索引时的行锁升级（因无法精准定位行）。

   * **意向锁作用**：表级锁，分为意向共享锁（IS）和意向排他锁（IX），用于快速判断表中是否有行被加锁（例如，事务想加表锁时，无需逐行检查是否有行锁，只需检查意向锁即可），减少锁检查的开销。

5. **explain 优化 SQL**：使用 explain 分析 SQL 语句时，结果中的 type 列有哪些取值？不同取值代表什么含义？

   type表示查询的扫描方式，效率从高到低为：

   * **system**：表只有一行数据（如系统表），是const的特例；
   * **const**：通过主键或唯一索引查询，结果只有一行，如`where id=1`；
   * **eq_ref**：唯一索引扫描，多表连接时，被连接表的每行仅匹配一行，如`a.id = b.a_id`（b.a_id是唯一索引）；
   * **ref**：非唯一索引扫描，匹配多行，如`where name='xxx'`（name是非唯一索引）；
   * **ref_or_null**：类似ref，但包含对NULL值的查询，如`where name='xxx' or name is null`；
   * **range**：索引范围扫描，如`where id between 1 and 10`或`like 'xxx%'`；
   * **index**：全索引扫描（遍历整个索引树），比ALL快（索引数据量通常小于表数据）；

   * **ALL**：全表扫描（未使用索引），效率最低。

6. **分库分表**：什么是水平分表和垂直分表？它们各自适用于什么场景？

   * **水平分表**：按规则（如时间、用户ID哈希、地区）将一个大表的数据分散存储到多个结构相同的子表中（如按月份分表`order_202501`、`order_202502`）。

     适用场景：单表数据量过大（如千万级以上）导致查询/写入变慢；高并发下写操作频繁，单表IO压力大。

   * **垂直分表**：按字段热度拆分（常用字段放主表，大字段/冷字段放扩展表，如`user`表拆分为`user_base`（id、name等）和`user_extra`（avatar、intro等），通过主键关联）。

     适用场景：表字段过多（如100+字段），单行数据过大导致存储行数少（IO效率低）；核心查询只依赖少数字段，无需加载全表数据。

7. **日志原理**：MySQL 中的 redo log 和 undo log 分别有什么作用？

   * redo log：
     * 作用：保证事务的持久性，记录数据页的物理修改（如“页100中偏移量50的值从A改为B”）；
     * 特性：循环写（固定大小），采用WAL机制（先写日志再写磁盘），崩溃后可通过redo log恢复未刷盘的修改。
   * undo log：
     * 作用：保障事务的原子性（记录反向操作，如“插入”对应“删除操作”，用于回滚）；实现MVCC（多版本并发控制）关键因素之一，通过undo log生成数据版本链，供读已提交/可重复读级别的快照读使用）；
     * 特性：逻辑日志，事务提交后可被purge线程删除（无需长期保留）。

8. **B + 树索引实践**：假设有一张表，为多个字段建立了联合索引，查询时如何利用该联合索引提高效率？

   利用联合索引需遵循以下原则：

   * **最左匹配原则**：查询条件需包含联合索引的最左前缀（如索引`(a,b,c)`，`where a=1 and b=2`可命中，`where b=2`不可）；
   * **范围条件限制**：范围查询（`>、<、between`等）后的字段无法使用索引（如`where a=1 and b>2 and c=3`，`c`无法命中索引）；
   * **避免索引失效操作**：索引列不参与函数/表达式计算（如`where left(a,3)='xxx'`失效），不使用`not in、!=`等可能导致全表扫描的操作；
   * **覆盖索引优先**：若查询字段均可从联合索引中获取（如`select a,b from t where a=1`，索引`(a,b)`可覆盖），无需回表，效率更高。

9. **事务特性**：事务的 ACID 特性指的是什么？InnoDB 是如何保证这些特性的？

   ACID即原子性、一致性、隔离性、持久性：

   * 原子性：通过undo log实现，事务失败时执行undo log中的反向操作，回滚所有变更；

   * 持久性：通过redo log实现，事务提交后，即时数据未刷入磁盘，也可通过redo log恢复；
   * 隔离性：通过MVCC（多版本并发控制，基于undo log版本链和Read View）和锁机制（行锁、表锁、间隙锁等）实现，避免并发干扰；
   * 一致性：由原子性、持久性、隔离性共同保障，同时依赖数据库约束（主键、外键、check等）和业务逻辑（如转账时的金额校验），确保数据从一个有效状态转换到另一个有效状态。

10. **索引失效**：在使用 B + 树索引时，哪些情况可能导致索引失效？

    常见索引失效场景包括：

    * 索引列使用函数或表达式（如`where year(create_time)=2025`）；

    * 左模糊或全模糊匹配（如`where name like '%xxx'`或`%xxx%`，前缀匹配`xxx%`有效）；
    * 联合索引没有遵循最左匹配原则（如索引`(a,b)`，`where b=1`失效）；
    * OR条件中，OR前的条件列是索引列而OR后的条件列不是索引列的时候（如`where a=1 or b=1`，b无索引则a的索引失效）；
    * 使用`!=、<>、not in、is not null`等操作（优化器可能认为全表扫描更快）；
    * 字符字段集不匹配（如字段为utf8mb4，查询用latin1，导致隐式转换）；
    * 优化器判断全表扫描更高效（如数据量极小，或统计信息过时导致误判）。

---

1. **InnoDB 存储引擎追问**：你了解的 InnoDB 存储引擎机制里，聚簇索引和非聚簇索引在数据存储上有什么不同？如果表没有显式定义主键，InnoDB 会怎么处理？

   数据存储：

   * 聚簇索引叶子节点存储的实际数据即完整的行数据；
   * 非聚簇索引叶子节点存储对应记录的主键值（通过主键值回表查询完整数据）。

   如果表没有显示定义主键，InnoDB处理方式：

   * 检查是否有非空的唯一索引，如果表中有非空的唯一索引，InnoDB会选择第一个符合条件的唯一索引作为主键（按索引定义的顺序）；

   * 如果没有符合条件的唯一索引，InnoDB自动创建一个6字节的隐式自增主键（这个隐式主键对用户不可见，不在表结构中显示）。

2. **B + 树索引追问**：熟悉 B + 树索引的话，那你知道为什么 B + 树索引不建议建在区分度低的字段（比如性别）上吗？联合索引的最左匹配原则，在查询条件里有范围查询时会受影响吗？

   性别的区分度很小，不适合建立索引或不适合排在联合索引列的靠前的位置，字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据，MySQL有一个查询优化器，发现某个值出现在表的数据行的百分比（一般是30%）很高时，一般会忽略索引，进行全表扫描。

   联合索引的最左匹配原则，在遇到范围查询（如>、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引（对于>=、<=、between、like前缀匹配的范围查询，并不会停止匹配）。

3. **事务隔离级别追问**：知道事务隔离级别，那你能说说在可重复读隔离级别下，两次查询同一批数据，结果为什么能保持一致？这种一致性是怎么实现的？

   在可重复读隔离级别下，事务两次查询同一批数据，结果能保持一致是通过MVCC（多版本并发控制）和Read View来实现的。

   对于MVCC，InnoDB通过以下方式维护数据多版本：

   * 每行记录包含两个隐藏字段：
     * `DB_TRX_ID`：最近修改该行的事务ID
     * `DB_ROLL_PTR`：指向该行历史版本的undo日志指针

   * 更新操作不会直接覆盖数据，而是创建新版本

   对于Read View，事务在第一次执行查询时会生成一个Read View，包含：

   * `m_ids`：当前活跃但未提交的事务ID集合
   * `min_trx_id`：活跃事务中最小ID
   * `max_trx_id`：系统预分配的下一个事务的ID
   * `creator_trx_id`：创建该Read View的事务ID

   第一次查询时，创建Read View，后续查询复用同一个Read View，对于每一行数据，通过比较`DB_TRX_ID`和Read View判断是否可见：

   1. `DB_TRX_ID`<`min_trx_id`，已提交事务修改，可见
   2. `DB_TRX_ID`>=`max_trx_id`，将来事务修改，不可见
   3. `min_trx_id`<=`DB_TRX_ID`<`max_trx_id`，如果`DB_TRX_ID`在`m_ids`中，事务未提交，不可见，否则事务已提交，可见
   4. `DB_TRX_ID`=`creator_trx_id`，当前事务修改，可见

4. **锁机制基础追问**：掌握锁机制基础，那行锁在什么情况下可能会升级成表锁？如果两个事务都对同一张表的不同行加行锁，会产生锁冲突吗？

   使用当前读语句（`select ... for update`加排他锁X，`select ... lock in share mode`加共享锁S）时，若查询命中索引，会对匹配的行加行锁；若未命中索引，会升级为表锁。

   两个事务都对同一张表的不同行加行锁：

   * 不会产生冲突的情况：
     * 两个事务都只是读取数据（共享锁S）；
     * 两个事务锁定不同行且都是行级排他锁X。

   * 可能会产生冲突的情况：

     * 间隙锁冲突：

       ```sql
       -- 事务1（假设id=5不存在）
       SELECT * FROM table WHERE id = 5 FOR UPDATE;
       
       -- 事务2
       INSERT INTO table VALUES (4, ...);  -- 可能被阻塞
       ```

       即使操作的是不同行，如果事务1在id=5上加了间隙锁，可能锁定了(1,5]或(4,6]这样的区间，会阻塞事务2在间隙内的插入操作；

     * Next-Key Lock冲突：

       ```sql
       -- 事务1（假设id有10,20,30）
       SELECT * FROM table WHERE id > 15 FOR UPDATE;
       
       -- 事务2
       SELECT * FROM table WHERE id = 20 FOR UPDATE;  -- 被阻塞
       ```

       事务1锁定了(15,20]，(20,30]等区间，会阻塞事务2对20的锁定。

5. **explain 优化 SQL 追问**：会用 explain 优化 SQL，那 explain 结果里的 key 列和 key_len 列分别代表什么？如果 key 列显示为 NULL，一定是没用到索引吗？

   key表示实际使用的索引，key_len表示索引的长度。如果key列显示NULL，说明没有使用索引。

6. **分库分表追问**：了解分库分表，那水平分表后，怎么解决跨表的 count 统计问题？如果按用户 ID 哈希分表，后续数据量增长需要扩容，该怎么处理？

7. **日志原理追问**：知道日志原理，那 redo log 和 binlog 有什么区别？为什么 InnoDB 需要同时有这两种日志？

8. **InnoDB 延伸追问**：了解 InnoDB 机制，那你知道 InnoDB 的缓冲池（Buffer Pool）是做什么的？它里面主要缓存哪些数据？

9. **索引实践追问**：熟悉 B + 树索引，那在设计索引时，是给每个查询条件都建索引好，还是有选择地建？多索引共存会对写入操作有什么影响？

10. **事务实践追问**：知道事务隔离级别，那你在写 SQL 时，有没有遇到过事务并发导致的问题？如果有，是怎么解决的？如果没有，那你能设想一个可能出现并发问题的场景吗？

